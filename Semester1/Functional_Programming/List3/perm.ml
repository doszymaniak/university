module type OrderedType = sig
  type t
  val compare : t -> t -> int
end

module type S = sig
  type key
  type t
  val apply : t -> key -> key
  val id : t
  val invert : t -> t
  val swap : key -> key -> t
  val compose : t -> t -> t
  val compare : t -> t -> int
end

(* Implementation of permutation as a map key -> key *)
module Make (Key : OrderedType) = struct
  type key = Key.t

  module M = Map.Make(Key)

  type t =
  {
    f : key M.t; (* key -> key map *)
    f_inv : key M.t (* inverse map for fast inversion *)
  } 

  let apply map key = 
    match M.find_opt key map.f with
    | Some v -> v
    | None -> key

  let id =
  {
    f = M.empty;
    f_inv = M.empty
  }

  let invert map = { f = map.f_inv; f_inv = map.f }

  let swap key1 key2 =
    let f' = M.empty |> M.add key2 key1 |> M.add key1 key2 in
    { f = f'; f_inv = f' }

  (* Composition map1 âˆ˜ map2 for key k is apply map1 (apply map2 k) *)
  let compose map1 map2 = 
    let aux_fun key map1_opt map2_opt =
      let v2 = 
        match map2_opt with
        | Some v -> v
        | None -> key 
      in 
      let v1 = 
        match M.find_opt v2 map1.f with
        | Some v -> v
        | None -> v2
      in 
      if Key.compare key v1 = 0 then None (* we want to preserve the invariant *)
      else Some v1
    in 
    let f' = M.merge aux_fun map1.f map2.f in 
    let f_inv' = M.fold (fun k v acc -> M.add v k acc) f' M.empty in
    { f = f'; f_inv = f_inv' }
  
  let compare map1 map2 = M.compare Key.compare map1.f map2.f 
end

(* Check if a permutation is generated by a set of permutations *)
module MakeIsGenerated (Perm : S) = struct
  module PermOrdered = struct
    type t = Perm.t
    let compare = Perm.compare
  end

  module S = Set.Make(PermOrdered)

  let is_generated perm g =
    (* Start with given set + identity *)
    let init_set = List.fold_left (fun acc p -> S.add p acc) S.empty g in
    let init_set = init_set |> S.add Perm.id in 
    
    (* Recursively close the set *)
    let rec saturate curr_set =
      let with_inv = S.fold (fun p acc -> S.add (Perm.invert p) acc) curr_set curr_set in
      let composed = S.fold (fun p1 acc ->
        S.fold (fun p2 in_acc -> S.add (Perm.compose p1 p2) in_acc) curr_set acc 
      ) curr_set S.empty in
      let new_set = S.union (S.union curr_set with_inv) composed in 
      if S.mem perm new_set then true 
      else if S.equal new_set curr_set then false 
      else saturate new_set 
    
    in saturate init_set
end